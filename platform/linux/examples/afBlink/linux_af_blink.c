/**
   Copyright 2015-2018 Afero, Inc.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

/*
   afBlink is a simple "hello world" type application that blinks the LED
   of a Modulo development board. This application shows the bare minimum
   code required to communicate with the Afero Cloud. More robust examples of
   how to do everything you can do with this library are available in the
   developer documentation and other example apps.

   TERMS: In the comments of this code, we'll use the words "Modulo" and "ASR"
          a lot, and sometimes it may seem they're interchangeable, though they
          are not. The ASR is the Afero Secure Radio module that is the heart
          of the communication between the MCU and the Afero Cloud. "Modulo"
          is the name of the physical Afero Development Board that you can use
          to prototype your hardware and software. The Modulo development board
          includes an ASR, of course, along with some other things to make
          development easier - a voltage regulator, a USB-Serial interface, and
          an LED and button connected to the ASR's GPIO pins for simple interaction.
          We'll try to be as consistent as possible to say "Modulo" when we are
          talking about something specific to the Modulo hardware (LED, button,
          and physical pin connections to the MCU) and say "ASR" all other times
          when referring to the communication between the MCU and the Afero Cloud.
*/



#include "af_lib.h"
#include "af_logger.h"
#include "af_module_states.h"
#include "af_module_commands.h"
#include "af_utils.h"
#include "linux_uart.h"
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <poll.h>
#include <time.h>

// device-description.h is generated by Profile Editor
#include "profile/afBlink2/device-description.h"

// For Modulo-1 UART speed is fixed at 9600
// For all other Modulo boards the UART_BAUD_RATE here must match the UART speed set in Profile Editor
#define UART_BAUD_RATE            "9600"

af_lib_t* sAf_lib = NULL;
bool asrReady = false;          // If false, we're waiting on AF_MODULE_STATE_INITIALIZED, if true, we can communicate with ASR
bool asrRebootPending = false;  // If true, a reboot is needed, e.g. if we received an OTA firmware or profile update.
bool asrSyncPending = false;    // If true, we've just rebooted, so update the Modulo with our MCU attribute values

// variables to monitor and control blink state
volatile long lastBlink = 0;                   // Time of last blink
volatile bool blinking = false;                // Track whether LED is blinking; represented by attribute AF_BLINK
volatile bool moduloLEDState = false;          // Track whether the Modulo LED is on
uint16_t prevButtonValue = 0;                  // Track the button value...
uint16_t curButtonValue = 0;                   // ...so we know when it has changed

// Set a blink interval.
// We can send requests at a longer interval, of course, but we should try not to send
// requests faster than this interval so the ASR doesn't get overwhelmed.
#define BLINK_INTERVAL            2000  // 2 seconds

// forward reference for the dbugging call
void printAttribute(const uint16_t attributeId, const uint16_t valueLen, const uint8_t* value);

// Turn the Modulo LED off and on by setting the state of the ASR's GPIO0 pin.
void setModuloLED(bool state) {
    if (moduloLEDState != state) {
        int result = af_lib_set_attribute_16(sAf_lib, AF_MODULO_LED, state);
        if (result != AF_SUCCESS) {
            // A more robust app would retry or act on the specific error returned
            printf("Set LED returned error: %d\n", result);
        }
        moduloLEDState = state;
    }
}

// This callback is executed any time ASR has information for the MCU
// The name of this event is defined in the aflib initialization in setup()
void attrEventCallback(const af_lib_event_type_t eventType,
                       const af_lib_error_t error,
                       const uint16_t attributeId,
                       const uint16_t valueLen,
                       const uint8_t* value) {

    // Print out the attribute and its value
    printAttribute(attributeId, valueLen, value);

    switch (eventType) {
        case AF_LIB_EVENT_ASR_NOTIFICATION:
            // Unsolicited notification when a non-MCU attribute changes state
            switch (attributeId) {
                case AF_MODULO_LED:
                    // Update the state of the LED based on the actual attribute value.
                    moduloLEDState = (*value == 1);
                    break;

                case AF_MODULO_BUTTON:
                    // curButtonValue is checked in loop(). If changed, will toggle the blinking state there
                    curButtonValue = *(uint16_t*) value;
                    break;

                case AF_SYSTEM_ASR_STATE:
                    af_logger_print_buffer("ASR state=");
                    switch (value[0]) {
                        case AF_MODULE_STATE_REBOOTED:
                            af_logger_println_buffer("Rebooted");
                            asrReady = false;   // Rebooted, so we we can't talk to it yet
                            break;

                        case AF_MODULE_STATE_LINKED:
                            af_logger_println_buffer("Linked");
// "Linked" is the final connected state returned by the Modulo-1
// all other devices will return an Initialized state below when connection is completed
#if AF_BOARD == AF_BOARD_MODULO_1
                            asrReady = true;
                            asrSyncPending = true;
#endif
                            break;

                        case AF_MODULE_STATE_UPDATING:
                            af_logger_println_buffer("Updating");
                            break;

                        case AF_MODULE_STATE_UPDATE_READY:
                            af_logger_println_buffer("Updated, need reboot");
                            asrRebootPending = true;
                            break;

                        case AF_MODULE_STATE_INITIALIZED:
                            af_logger_println_buffer("Initialized");
#if AF_BOARD != AF_BOARD_MODULO_1
                            asrReady = true;
                            asrSyncPending = true;
#endif
                            asrReady = true;
                            asrSyncPending = true;
                            break;

                    }
                    break;

                default:
                    break;
            }
            break;

        case AF_LIB_EVENT_MCU_SET_REQUEST:
            // Request from ASR to MCU to set an MCU attribute, requires a call to af_lib_send_set_response()
            switch (attributeId) {
                case AF_BLINK:
                    // This MCU attribute controls whether we should be blinking.
                    blinking = (*value == 1);
                    // We just echo back what the ASR sent us, to let it know we were successful
                    // If we can't set this value, we'd return false below and value would be the "old"
                    // value that the update didn't affect
                    af_lib_send_set_response(sAf_lib, AF_BLINK, true, valueLen, value);
                    break;
                    break;

                default:
                    break;
            }
            break;

        default:
            break;
    }


}

static int usage()
{
    fprintf(stdout, "afBlink -b [uartBaudRate] -D [uartDevicePath]\n");
    return -1;
}

int main(int argc, char *argv[])
{
    char *uart_baud_rate = NULL;
    char *uart_device_path = NULL;

#if defined(UART_BAUD_RATE)
    uart_baud_rate = UART_BAUD_RATE;
#endif

    for (int i = 1; i < argc; i++) {
        const char* s = argv[i];
        if (s[0] == '-')
        {
            switch(s[1]) {
                case 'b':
                    if (i == argc-1) {
                        return usage();
                    }
                    uart_baud_rate = argv[++i];
                    break;
                case 'D':
                    if (i == argc-1) {
                        return usage();
                    }
                    uart_device_path = argv[++i];
                    break;
                default:
                    return usage();
            }
        } else
            usage();
    }

    if (!uart_baud_rate && !uart_device_path) {
        return usage();
    }

    fprintf(stdout, "afBlink using uart path %s and baud rate %s\n", uart_device_path, uart_baud_rate);

    uint32_t baud_rate = atoi(uart_baud_rate);

    af_transport_t *linux_uart = linux_uart_create(uart_device_path, baud_rate);

    sAf_lib = af_lib_create_with_unified_callback(attrEventCallback, linux_uart);

    struct timespec sleep_time;
    struct timespec remaining;
    sleep_time.tv_sec = 0;
    sleep_time.tv_nsec = 250000;
    nanosleep(&sleep_time, &remaining);

    while (1) {
        // ALWAYS give the afLib state machine time to do its work - avoid blind delay() calls
        // of any length, instead repeat calls to af_lib_loop() while waiting for whatever it is
        // you're waiting to happen. Some afLib operations take multiple loop() calls to complete.
        af_lib_loop(sAf_lib);
        fflush(stdout);

        // Until the ASR is initialized, we shouldn't talk to it, if it's not ready we just exit loop() altogether.
        if (!asrReady) continue;

        // asrReady == true from here on down
        // If we were asked to reboot (e.g. after an OTA firmware update), do it now.
        if (asrRebootPending) {
            int retVal = af_lib_set_attribute_32(sAf_lib, AF_SYSTEM_COMMAND, AF_MODULE_COMMAND_REBOOT);
            // If retVal returns an error, leave asrRebootPending set to try it again next time around
            asrRebootPending = (retVal != AF_SUCCESS);
            // if retVal returned success, then we wait for the ASR reboot to happen
            if (!asrRebootPending) {
                asrReady = false;
            }
        }

        // After ASR is initialized, we need to send it the values of all of our MCU attributes (we only have 1 in this app)
        // "blinking" defautls to false at MCU boot, but it may not be false if the ASR reboots and we stay running
        if (asrSyncPending) {
            if (af_lib_set_attribute_bool(sAf_lib, AF_BLINK, blinking) == AF_SUCCESS) {
                asrSyncPending = false;
            }
        }

        // If the Modulo button was pressed (in attrEventHandler), toggle 'blinking'
        if (prevButtonValue != curButtonValue) {
            if (af_lib_set_attribute_bool(sAf_lib, AF_BLINK, !blinking) == AF_SUCCESS) {
                if (!blinking) setModuloLED(false);
                blinking = !blinking;
                prevButtonValue = curButtonValue;
            }
        }

        // Flash the LED whenever the 'blinking' value is true
        if (blinking) {
            if (af_utils_millis() - lastBlink > BLINK_INTERVAL) {
                setModuloLED(!moduloLEDState);
                lastBlink = af_utils_millis();
            }
        }
    }

    return 0;
}

// Debugging Stuff

// Arduino Uno boards have inadequate memory to tolerate pretty-printing debug methods
// so these are pretty basic just to show program flow.
#define ATTR_PRINT_BUFFER_LEN     40

char attr_print_buffer[ATTR_PRINT_BUFFER_LEN];

void getPrintAttrHeader(const char* attrLabel, const uint16_t attributeId,
                        const uint16_t valueLen) {
    memset(attr_print_buffer, 0, ATTR_PRINT_BUFFER_LEN);
    snprintf(attr_print_buffer, ATTR_PRINT_BUFFER_LEN, "attr %s=", attrLabel);
}

void
printAttrBool(const char* attrLabel, const uint16_t attributeId, const uint16_t valueLen,
              const uint8_t* value) {
    getPrintAttrHeader(attrLabel, attributeId, valueLen);
    if (valueLen > 0) {
        strcat(attr_print_buffer, *value == 1 ? "true" : "false");
    }
    af_logger_println_buffer(attr_print_buffer);
}


void
printAttr16(const char* attrLabel, const uint16_t attributeId, const uint16_t valueLen,
            const uint8_t* value) {
    getPrintAttrHeader(attrLabel, attributeId, valueLen);
    if (valueLen > 0) {
        char intStr[6];
        snprintf(intStr, sizeof(intStr), "%d", *((int16_t *)value));
        strcat(attr_print_buffer, intStr);
    }
    af_logger_println_buffer(attr_print_buffer);
}

void
printAttrStr(const char* attrLabel, const uint16_t attributeId, const uint16_t valueLen,
             const uint8_t* value) {
    getPrintAttrHeader(attrLabel, attributeId, valueLen);
    int len = strlen(attr_print_buffer);
    for (int i = 0; i < valueLen; i++) {
        attr_print_buffer[len + i] = (char) value[i];
    }
    af_logger_println_buffer(attr_print_buffer);
}

void printAttribute(const uint16_t attributeId, const uint16_t valueLen, const uint8_t* value) {
    switch (attributeId) {
        case AF_BLINK:
            printAttrBool("BLINK", attributeId, valueLen, value);
            break;

        case AF_MODULO_LED:
            printAttr16("Modulo LED", attributeId, valueLen, value);
            break;

        case AF_MODULO_BUTTON:
            printAttr16("Modulo Button", attributeId, valueLen, value);
            break;

        case AF_APPLICATION_VERSION:
            printAttr16("FW Version", attributeId, valueLen, value);
            break;

        case AF_PROFILE_VERSION:
            printAttr16("Profile Version", attributeId, valueLen, value);
            break;

        case AF_SYSTEM_REBOOT_REASON:
            // This attribute can be very long, but the first few characters are all we
            // generally care about
            printAttrStr("Reboot Reason", attributeId, 9, value);
            break;
    }
}

