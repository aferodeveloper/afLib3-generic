/**
 * Copyright 2018 Afero, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#include "af_lib.h"
#include "af_logger.h"
#include "af_module_states.h"
#include "af_module_commands.h"
#include "af_utils.h"
#include "linux_uart.h"
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <poll.h>
#include <time.h>

// device-description.h is generated by Profile Editor
#include "profile/afBlink2/device-description.h"

af_lib_t* sAf_lib = NULL;
long lastBlink = 0;
bool blinking = false;
bool moduloLEDIsOn = false;      // Track whether the Modulo LED is on
uint16_t moduleButtonValue = 1;  // Track the button value so we know when it has changed

// Blink as fast as we can. There is a minimum time between requests defined
// by the afLib. We can send requests slower than this, but try not to send
// requests faster than this so the ASR doesn't get overwhelmed.
#define BLINK_INTERVAL            1000

// Modulo LED is active low
#define LED_OFF                   1
#define LED_ON                    0

#define ATTR_PRINT_HEADER_LEN     60
#define ATTR_PRINT_MAX_VALUE_LEN  512   // Each byte is 2 ASCII characters in HEX.
#define ATTR_PRINT_BUFFER_LEN     (ATTR_PRINT_HEADER_LEN + ATTR_PRINT_MAX_VALUE_LEN)

char attr_print_buffer[ATTR_PRINT_BUFFER_LEN];

#define POLL_TIMEOUT                (1 * 100) /* 3 seconds */
#define MAX_BUF                     256

static void setModuloLED(int on) {
    if (moduloLEDIsOn != on) {
        int16_t attrVal = on ? LED_ON : LED_OFF; // Modulo LED is active low
        if (af_lib_set_attribute_16(sAf_lib, AF_MODULO_LED, attrVal) != AF_SUCCESS) {
            printf("Could not set LED\n");
            af_lib_loop(sAf_lib);
        }
        moduloLEDIsOn = on;
    }
}

static void toggleModuloLED() {
    setModuloLED(!moduloLEDIsOn);
}

static void getPrintAttrHeader(const char *sourceLabel, const char *attrLabel, const uint16_t attribute_id, const uint16_t value_len) {
    memset(attr_print_buffer, 0, ATTR_PRINT_BUFFER_LEN);
    snprintf(attr_print_buffer, ATTR_PRINT_BUFFER_LEN, "%s id: %s len: %05d value: ", sourceLabel, attrLabel, value_len);
}

static void printAttrBool(const char *sourceLabel, const char *attrLabel, const uint16_t attribute_id, const uint16_t value_len, const uint8_t *value) {
    getPrintAttrHeader(sourceLabel, attrLabel, attribute_id, value_len);
    if (value_len > 0) {
        strcat(attr_print_buffer, *value == 1 ? "true" : "false");
    }
    af_logger_println_buffer(attr_print_buffer);
}

static void printAttr8(const char *sourceLabel, const char *attrLabel, const uint8_t attribute_id, const uint16_t value_len, const uint8_t *value) {
    getPrintAttrHeader(sourceLabel, attrLabel, attribute_id, value_len);
    if (value_len > 0) {
        char intStr[6];
        snprintf(intStr, sizeof(intStr), "%d", *((int8_t *)value));
        strcat(attr_print_buffer, intStr);
    }
    af_logger_println_buffer(attr_print_buffer);
}

static void printAttr16(const char *sourceLabel, const char *attrLabel, const uint16_t attribute_id, const uint16_t value_len, const uint8_t *value) {
    getPrintAttrHeader(sourceLabel, attrLabel, attribute_id, value_len);
    if (value_len > 0) {
        char intStr[6];
        snprintf(intStr, sizeof(intStr), "%d", *((int16_t *)value));
        strcat(attr_print_buffer, intStr);
    }
    af_logger_println_buffer(attr_print_buffer);
}

static void printAttr32(const char *sourceLabel, const char *attrLabel, const uint16_t attribute_id, const uint16_t value_len, const uint8_t *value) {
    getPrintAttrHeader(sourceLabel, attrLabel, attribute_id, value_len);
    if (value_len > 0) {
        char intStr[11];
        snprintf(intStr, sizeof(intStr), "%d", *((int32_t *)value));
        strcat(attr_print_buffer, intStr);
    }
    af_logger_println_buffer(attr_print_buffer);
}

static void printAttrHex(const char *sourceLabel, const char *attrLabel, const uint16_t attribute_id, const uint16_t value_len, const uint8_t *value) {
    getPrintAttrHeader(sourceLabel, attrLabel, attribute_id, value_len);
    for (int i = 0; i < value_len; i++) {
        char hexStr[4];
        snprintf(hexStr, sizeof(hexStr), "%02X", value[i]);
        strcat(attr_print_buffer, hexStr);
    }
    af_logger_println_buffer(attr_print_buffer);
}

static void printAttrStr(const char *sourceLabel, const char *attrLabel, const uint16_t attribute_id, const uint16_t value_len, const uint8_t *value) {
    getPrintAttrHeader(sourceLabel, attrLabel, attribute_id, value_len);
    int len = strlen(attr_print_buffer);
    for (int i = 0; i < value_len; i++) {
        attr_print_buffer[len + i] = (char)value[i];
    }
    af_logger_println_buffer(attr_print_buffer);
}

static void printAttribute(const char *label, const uint16_t attribute_id, const uint16_t value_len, const uint8_t *value) {
    switch (attribute_id) {
        case AF_BLINK:
            printAttrBool(label, "AF_BLINK", attribute_id, value_len, value);
            break;

        case AF_MODULO_LED:
            printAttr16(label, "AF_MODULO_LED", attribute_id, value_len, value);
            break;

        case AF_GPIO_0_CONFIGURATION:
            printAttrHex(label, "AF_GPIO_0_CONFIGURATION", attribute_id, value_len, value);
            break;

        case AF_MODULO_BUTTON:
            printAttr16(label, "AF_MODULO_BUTTON", attribute_id, value_len, value);
            break;

        case AF_GPIO_3_CONFIGURATION:
            printAttrHex(label, "AF_GPIO_3_CONFIGURATION", attribute_id, value_len, value);
            break;

        case AF_BOOTLOADER_VERSION:
            printAttrHex(label, "AF_BOOTLOADER_VERSION", attribute_id, value_len, value);
            break;

        case AF_APPLICATION_VERSION:
            printAttrHex(label, "AF_APPLICATION_VERSION", attribute_id, value_len, value);
            break;

        case AF_PROFILE_VERSION:
            printAttrHex(label, "AF_PROFILE_VERSION", attribute_id, value_len, value);
            break;

        case AF_SYSTEM_ASR_STATE:
            printAttr8(label, "AF_SYSTEM_ASR_STATE", attribute_id, value_len, value);
            break;

        case AF_SYSTEM_LOW_POWER_WARN:
            printAttr8(label, "AF_ATTRIBUTE_LOW_POWER_WARN", attribute_id, value_len, value);
            break;

        case AF_SYSTEM_REBOOT_REASON:
            printAttrStr(label, "AF_REBOOT_REASON", attribute_id, value_len, value);
            break;

        case AF_SYSTEM_MCU_INTERFACE:
            printAttr8(label, "AF_SYSTEM_MCU_INTERFACE", attribute_id, value_len, value);
            break;

        case AF_SYSTEM_LINKED_TIMESTAMP:
            printAttr32(label, "AF_SYSTEM_LINKED_TIMESTAMP", attribute_id, value_len, value);
            break;
    }
}

bool attr_set_handler_callback(const uint8_t request_id, const uint16_t attribute_id, const uint16_t value_len, const uint8_t *value) {
    printAttribute("attrSetHandler", attribute_id, value_len, value);

    switch (attribute_id) {
        // This MCU attribute tells us whether we should be blinking.
        case AF_BLINK:
            blinking = (*value == 1);
            break;

        default:
            break;
    }

    // Return false here if your hardware was unable to perform the set request from the service.
    // This lets the service know that the value did not change.
    return true;
}

void attr_notify_handler_callback(const uint8_t request_id, const uint16_t attribute_id, const uint16_t value_len, const uint8_t *value)
{
    printAttribute("attrNotifyHandler", attribute_id, value_len, value);

    switch (attribute_id) {
        // Update the state of the LED based on the actual attribute value.
        case AF_MODULO_LED:
            moduloLEDIsOn = (*value == 0);
            break;

            // Allow the button on Modulo to control our blinking state.
        case AF_MODULO_BUTTON: {
            uint16_t *buttonValue = (uint16_t *) value;
            if (moduleButtonValue != *buttonValue) {
                moduleButtonValue = *buttonValue;
                blinking = !blinking;
                fprintf(stdout, "blinking %d\n", blinking);
                if (af_lib_set_attribute_bool(sAf_lib, AF_BLINK, blinking) != AF_SUCCESS) {
                    af_logger_println_buffer("Could not set BLINK");
                }
            }
        }
            break;

        case AF_SYSTEM_ASR_STATE:
            af_logger_print_buffer("ASR state: ");
            switch (value[0]) {
                case AF_MODULE_STATE_REBOOTED:
                    af_logger_println_buffer("Rebooted");
                    if (af_lib_set_attribute_bool(sAf_lib, AF_BLINK, blinking) != AF_SUCCESS) {
                        af_logger_println_buffer("Could not set BLINK");
                    }
                    break;

                case AF_MODULE_STATE_LINKED:
                    af_logger_println_buffer("Linked");
                    break;

                case AF_MODULE_STATE_UPDATING:
                    af_logger_println_buffer("Updating");
                    break;

                case AF_MODULE_STATE_UPDATE_READY:
                    af_logger_println_buffer("Update ready - rebooting");
                    while (af_lib_set_attribute_32(sAf_lib, AF_SYSTEM_COMMAND, AF_MODULE_COMMAND_REBOOT) != AF_SUCCESS) {
                        af_lib_loop(sAf_lib);
                    }
                    break;

                default:
                    break;
            }
            break;

        default:
            break;
    }
}

static int usage()
{
    fprintf(stdout, "afBlink -b [uartBaudRate] -D [uartDevicePath]\n");
    return -1;
}

int main(int argc, char *argv[])
{
    char buf[MAX_BUF];
    int len;

    char *uart_baud_rate = NULL, *uart_device_path = NULL;

    for (int i = 1; i < argc; i++) {
        const char* s = argv[i];
        if (s[0] == '-')
        {
            switch(s[1]) {
                case 'b':
                    if (i == argc-1) {
                        return usage();
                    }
                    uart_baud_rate = argv[++i];
                    break;
                case 'D':
                    if (i == argc-1) {
                        return usage();
                    }
                    uart_device_path = argv[++i];
                    break;
                default:
                    return usage();
            }
        } else
            usage();
    }

    if (!uart_baud_rate && !uart_device_path) {
        return usage();
    }

    fprintf(stdout, "afBlink using uart path %s and baud rate %s\n", uart_device_path, uart_baud_rate);

    uint32_t baud_rate = atoi(uart_baud_rate);

    af_transport_t *linux_uart = linux_uart_create(uart_device_path, baud_rate);

    sAf_lib = af_lib_create(attr_set_handler_callback, attr_notify_handler_callback, linux_uart);

    struct timespec sleep_time;
    struct timespec remaining;
    sleep_time.tv_sec = 0;
    sleep_time.tv_nsec = 250000;
    nanosleep(&sleep_time, &remaining);

    while (1) {
        if (blinking) {
            if (af_utils_millis() - lastBlink > BLINK_INTERVAL) {
                toggleModuloLED();
                lastBlink = af_utils_millis();
            }
        } else {
            setModuloLED(false);
        }

        af_lib_loop(sAf_lib);
        fflush(stdout);
    }

    return 0;
}

